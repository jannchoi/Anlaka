# Anlaka - 안락한가

특정 지역의 매물을 확인하고 중개인과 소통하며 예약할 수 있는 부동산 앱입니다.

<br>

---
## 프로젝트 개요

- **최소 iOS 버전**: 16.0
- **디바이스 지원**: iPhone 전용
- **기술 스택**: SwiftUI, MVI Architecture, Realm, URLSession, Kakao Maps SDK, Core Location

<br>

---
## 주요 기능 

| 기능    | 설명                       |
| ----- | ------------------------ |
| 로그인   | 이메일, 카카오, 애플 로그인 기능      |
| 결제    | 인앱결제를 통한 예약금 결제 기능       |
| 채팅    | 웹소켓을 통한 실시간 채팅 기능        |
| 클러스터링 | 카카오맵 매물 표시               |
| 알림    | remote push notification |
| 프로필   | 프로필 수정 및 조회 기능           |

<br>

---
## 핵심 구현 내용

### 1. MVI 아키텍처 도입 - 단방향 데이터 플로우

이 프로젝트는 실시간 지도 기반 매물 검색, 복합 필터링, 결제 프로세스, WebSocket 채팅 등 다양한 기능을 포함하고 있습니다. 이러한 기능들로 인해 복잡한 비즈니스 로직과 상태 관리가 필요합니다. 따라서 뷰와 비즈니스 로직을 명확하게 분리하고, 뷰에서 발생하는 이벤트와 사용되는 데이터를 쉽게 파악하고 유연하게 수정, 확장할 수 있도록 MVI 아키텍처를 도입했습니다.

<br>

---
### 2. Factory + Internal 패턴을 통한 의존성 관리

이 프로젝트에서는 복잡한 데이터 요구사항을 가지고 있습니다:

- **다양한 데이터 소스**: 부동산 매물 정보, 사용자 인증, 결제 시스템, 채팅 데이터는 네트워크 API에서, 채팅 메시지 캐싱과 사용자 프로필은 로컬 데이터베이스에서, 지도와 결제는 외부 API에서 가져옵니다.
- **기능별 의존성 차이**: 채팅은 네트워크와 로컬 데이터베이스를 모두 사용하고, 매물 검색은 네트워크와 카카오맵 API를, 결제는 네트워크와 외부 결제 시스템을 연동해야 합니다.
- **테스트와 안정성**: 부동산 거래의 신뢰성을 위해 데이터 처리가 정확해야 하며, 복잡한 매물 타입과 필터링 로직에서 발생할 수 있는 버그를 줄이려면 테스트가 쉬운 구조가 필요합니다.

이러한 데이터의존성과 복잡한 비즈니스 로직을 효율적으로 관리하기 위해 **DIContainer**를 중심으로 **Factory+Internal패턴**을 결합한 **DI(의존성 주입)** 구조를 도입하였습니다.

**구현 방식**: <br>

1. **Factory + Internal 패턴**
- 의존성 생성을 Factory로 분리하고, `internal` 접근 제어를 통해 실제 구현체(`NetworkRepositoryImp`, `DatabaseRepositoryImp`)를 외부에서 직접 접근하지 못하도록 했습니다. 이를 통해 코드 간 연결을 최소화 하고 유지보수가 효율적으로 하였습니다.
 ```swift
internal enum NetworkRepositoryFactory {

static func create() -> NetworkRepository {

return NetworkRepositoryImp()

}

}

internal enum DatabaseRepositoryFactory {

static func create() throws -> DatabaseRepository {

return try DatabaseRepositoryImp()

}

}
```

2. **앱 시작 시 DIContainer 초기화** 
- 앱 시작 시 `DIContainer`를 한 번 생성해 모든 의존성을 초기화하고, 모든 Repository를 생성하고 관리합니다. 각 화면에 필요한 의존성만 주입하여 앱 전체에서 일관되게 데이터 소스를 관리할 수 있도록 하였습니다.
```swift
@MainActor

final class DIContainer: ObservableObject {

private let networkRepository: NetworkRepository

private let databaseRepository: DatabaseRepository

init() throws {

self.networkRepository = NetworkRepositoryFactory.create()

self.databaseRepository = try DatabaseRepositoryFactory.create()

}

}
```


3. **기능별 Container로 필요한 의존성 주입**
- 각 화면(로그인, 채팅, 매물 상세 등)은 독립적인 Container를 가지며, 필요한 Repository만 주입받아 사용합니다. 이를 통해 각 기능이 독립적으로 동작하며 불필요한 의존성이 생기지 않도록 하였습니다.
```swift
func makeLoginContainer() -> LoginContainer {

LoginContainer(repository: networkRepository)

}

func makeChattingContainer(roomId: String) -> ChattingContainer {

ChattingContainer(repository: networkRepository, databaseRepository: databaseRepository, roomId: roomId)

}

func makeEstateDetailContainer(estateId: String) -> EstateDetailContainer {

EstateDetailContainer(repository: networkRepository, estateId: estateId)

}
```


<br>

---
### 3. 동적 클러스터링을 통한 지도 매물 표시 최적화

#### 1. 격자 기반 클러스터링

- 지도 화면을 `6×3` 격자로 나누고, 각 격자에 포함된 매물을 하나의 클러스터로 그룹화하였습니다.
- Haversine 공식을 사용하여 위경도 차이를 실제 거리(미터)로 변환하고, 이를 기반으로 정확한 격자 크기를 설정하였습니다.
- 이를 통해 지도에 수백 개의 매물을 표시할 때도 성능과 가독성을 유지할 수 있도록 하였습니다.



#### 2. 줌 레벨에 따른 핀 표시 로직

##### **A. 넓은 영역 (구 단위 이상)**

- 매물 수가 많은 지역을 직관적으로 표현하기 위해 **클러스터 배지 + 핀 크기 조정**을 적용하였습니다.
- **핀 크기 조정 로직**:

  > 사용자가 매물 밀집도를 한눈에 파악할 수 있도록 핀 크기를 조정하였습니다.

  - **기본 규칙**:
    - 핀 크기는 최소 `30pt`, 최대 `격자 크기의 60%`로 제한하였습니다.  
    - 지도에 표시된 모든 지역의 매물 수가 동일할 경우, 핀 크기는 모두 동일하게 설정됩니다.
  - **상대적 크기 조정**:
    - 현재 화면에 표시된 클러스터 중 **가장 적은 매물 수와 가장 많은 매물 수를 기준**으로 범위를 설정합니다.
    - 각 클러스터의 **매물 수 비율**에 따라 핀 크기를 계산하며,  
      같은 매물 수라도 지도 전체의 분포 상황에 따라 상대적으로 다른 크기로 표현됩니다.
  - 이를 통해 사용자는 **매물 수가 적거나 많은 지역의 분포**를 직관적으로 파악할 수 있습니다.

- **시각 표현 보정**: 매물 수의 **제곱근을 적용한 루트 보간 알고리즘**을 사용하여, 과도한 크기 차이를 완화하였습니다.



##### **B. 좁은 영역 (구 단위 이하)**

- 클러스터 대신 **실제 매물의 대표 이미지**를 핀으로 표시하였습니다.
- 매물 수는 배지로 함께 표시하며, `99+`의 경우 배지 폰트 크기를 `10pt`로 축소하여 가독성을 확보하였습니다.
- **이미지 비동기 처리**:
  - `TaskGroup`을 활용하여 병렬 이미지 다운로드를 수행하였습니다.
  - 캐싱을 적용하여 동일 이미지에 대한 중복 요청을 방지하였습니다.



#### 3. 사용자 인터랙션 최적화

- **클러스터 확장**:
  - 낮은 줌 레벨에서 클러스터를 탭하면, 클러스터 내 매물 좌표를 포함하는 `AreaRect`를 생성하여 해당 영역으로 지도를 자동 확대합니다.
- **개별 매물 선택**:
  - 높은 줌 레벨에서는 단일 매물을 선택하면 즉시 상세 페이지로 이동하며,  
    다중 매물일 경우에는 하단 리스트 뷰로 매물 목록을 표시합니다.


#### 4. 실시간 매물 업데이트 및 필터링

- **디바운싱 처리**:
  - 지도 이동 또는 필터 변경 시 `0.7초`의 지연을 적용하여 불필요한 API 호출을 줄였습니다.
  - 화면 이동 거리가 `10m 이상`인 경우에만 데이터를 갱신하도록 하였습니다.
- **차분 렌더링**:
  - 기존 POI와 새로운 POI를 비교하여 필요한 객체만 추가하거나 제거함으로써 렌더링 부하를 최소화하였습니다.
- **필터 슬라이더 최적화**:
  - 필터 항목: 평수, 월세, 보증금 등
  - 사용자 편의를 높이기 위해 **가중치 기반 구간**으로 구성하였습니다.  
    예) 평수: 1–5–100–200 / 월세: 1–30–300–5000(만원)
  - 필터 변경 시 `0.7초 디바운싱` 후 지도를 즉시 업데이트하며,  
    최소/최대값이 전체 범위와 일치할 경우 필터링을 생략하여 성능을 최적화하였습니다.


#### 5. GeoCoding 및 검색 결과 처리

- **주소 + 키워드 통합 검색**을 통해 검색 정확도를 높였습니다.
  - 주소는 ‘상세주소 → 도로명주소 → 기본좌표’ 순으로 우선순위를 설정하여 정밀도를 확보하였습니다.
- **페이지네이션 적용**:
  - 검색 결과는 `30개 단위`로 나누어 순차적으로 로딩하였으며,  
    이를 통해 네트워크 부하를 최소화하였습니다.


---
### 4. 로그인 시스템

1. **다양한 로그인 방식 지원**
- 카카오, 애플, 이메일 로그인을 지원하여 간편하고 안전한 로그인 방식을 지원합니다. 
- 회원가입 시 필수값에 대한 유효성을 실시간으로 확인하고 시각적으로 피드백을 제공합니다.

2. **JWT 기반 자동 인증 및 로그인**
- **이중 토큰 구조**: Access Token(단기)과 Refresh Token(장기)
- **자동 토큰 갱신**: `NetworkManager`가 API 요청 전 Access Token의 만료 시간을 자동 확인하고, 만료 시 Refresh Token으로 갱신하여 사용자 개입 없이 매끄러운 경험을 제공합니다.
- **자동 로그인**: `@AppStorage`를 활용해 로그인 상태를 지속적으로 유지하여 기간 만료 시 자동으로 로그인 화면으로 전환합니다.

<br>

---
### 5. 3 계층 데이터 모델 구조 : DTO - Entity - Presentation

DTO-Entity-Presentation 3계층 구조를 채택하여 각 계층의 책임을 명확히 분리했습니다. 

- **DTO**
	- **역할**: 서버와 네트워크 통신에서 주고받는 원시 데이터를 처리합니다.
	- 모든 프로퍼티를 옵셔널로 선언해 서버에서 값이 누락되거나 형식 오류가 있을 경우 안전하게 수신하도록 하였습니다.

- **Entity**
	- **역할**: 앱 내부의 비즈니스 로직에서 사용하는 데이터 모델입니다.
	- `userId`와 같은 필수값은 DTO -> Entity 매핑 과정에서 `nil`을 반환하고 `CustomError.nilResponse`를 던져 필수 데이터 누락을 엄격히 관리합니다.
	- 따라서 비즈니스 계층에서는 유효한 데이터만 처리하도록 하였습니다.
```swift
extension DetailEstateResponseDTO {

func toEntity() -> DetailEstateEntity? {

guard let estateId = estateId, let creatorEntity = creator?.toEntity() else {

return nil // 필수 데이터 누락 시 nil 반환

}

return DetailEstateEntity(

estateId: estateId,

category: category ?? "알 수 없음", // 기본값 처리

title: title ?? "알 수 없음",

// ...

)

}

}
```

- **Presentaion**
	- **역할**: 뷰에 표시할 데이터를 처리합니다.
	- 모든 데이터를 `String` 타입으로 변환하여 뷰에서 타입 변환, 포맷팅, 옵셔널 처리를 하지 않도록 합니다.
	- `PresentationMapper`를 통해 금액, 면적, 층수, 날짜 등을 사용자 친화적인 형식으로 포맷팅합니다.
	- 이를 통해 뷰 레이어에서 복잡한 데이터 처리를 제거해 코드의 가독성을 높였습니다.

<br>

---
### 6. WebSocket 기반 실시간 채팅

- **기술** : Soket.IO, HTTP API, Realm, NWPathMonitor
1. **마지막 메시지 기준 동기화**
	- 채팅방 진입 시 네트워크 부하를 막고 로딩 시간을 줄이기 위해 로컬 DB에 저장된 마지막 메시지의 시간을 기준으로 서버에서 업데이트된 메시지만 가져옵니다.

2. **임시 메시지와 전송 상태 관리**
	- 사용자가 메시지 전송 버튼을 누르는 순간 `temp_ `접두사가 붙은 임시 ID로 메시지를 즉시 UI에 표시하고, 로딩 인디케이터를 띄워 전송 중임을 알립니다.
	- HTTP API로 성공 응답(실제 메시지 ID)을 받으면 임시 메시지를 실제 메시지로 교체하고 로컬 DB에 저장합니다.

3. **네트워크 연결 감지 및 재연결**
	- 네트워크 연결이 불안정한 환경에서도 채팅의 연속성을 유지하기 위해, 연결 상태를 실시간으로 감지하고 특정 횟수만큼 자동으로 재연결을 시도합니다.

<br>

---
### 7. 이미지 캐싱과 다운샘플링

이 프로젝트는 매물 정보를 조회할 때 이미지 경로를 받고, 이후 실제 이미지 데이터를 다운로드하는 2단계 네트워크 통신 구조를 가집니다. 또한, 한 화면에 여러 매물의 이미지를 보여줘야 하므로 빠른 이미지 로딩이 필요했습니다. 이를 위해 메모리와 디스크를 활용한 계층적 캐싱 시스템과 다운샘플링을 도입했습니다.

- **이미지 캐싱**
	- `NSCache`를 기반으로 하며, 이미지의 메모리 사용량을 픽셀 너비 × 픽셀 높이 × 4(RGBA) 방식으로 계산해 관리합니다.
	- **계층적 조회**: 메모리, 디스크, 네트워크 순으로 조회해 성능을 최적화하고, 불필요한 서버 요청을 줄이고자 했습니다.
	- **메모리 재저장**: 디스크에서 불러온 이미지를 메모리에 저장해 반복적인 디스크 접근을 줄이고, 빠른 이미지 로딩을 유지했습니다.

- **이미지 다운샘플링**
	- `ImageIO` 프레임워크의 `CGImageSource`를 사용해 비동기적으로 이미지를 처리합니다. 목표 크기(포인트) × 화면 스케일로 픽셀 크기를 계산하며, 썸네일이나 프로필 이미지처럼 가로 또는 세로가 100포인트 미만인 작은 이미지는 다운샘플링으로 용량을 줄이도록 하였습니다.


<br>

---

### 8. 결제 시스템 - 아임포트 기반 인앱결제

아임포트 SDK를 활용한 웹뷰 기반 결제 시스템을 구현하였습니다. 결제의 신뢰성과 사용자 경험을 위해 단방향 결제 흐름, 오류별 UX 분기 이중 검증 로직을 설계했습니다.

- **결제 프로세스**
	- 정보 검증 → SDK 웹뷰 호출 → `imp_uid` 반환 → 서버 검증 → 주문 확정의 단방향 흐름으로 설계하여 각 단계를 분리하여 명확한 오류 처리와 데이터 불일치 문제를 줄이도록 하였습니다.

- **결제 단계별 오류 처리**
	- 결제 시점에 따라 적절한 안내를 제공해 사용자의 혼란을 줄이고, 오류 상황에서도 신뢰감을 유지하려 했습니다.
		- **결제 정보 생성 오류**: "다시 시도" 버튼을 제공해 사용자가 즉시 재시도할 수 있도록 합니다.
		- **서버 검증 실패**(예: 결제 완료 후 금액 불일치): "고객센터 문의" 버튼을 띄워 사용자 손실을 방지합니다.
		- **결제 취소 또는 실패**: 사용자에게 명확한 오류 메시지를 표시합니다.

- **이중 서버 검증**
	- 서버에서 `imp_uid`를 통해 결제 상태와 금액을 재확인하는 이중 검증을 도입했습니다. 금액 매칭 로직은 결제 금액과 주문 금액의 불일치를 감지해 부정 결제를 방지하려 했습니다.
