# Anlaka - 안락한가

지도 기반 클러스터링을 중심으로 사용자가 원하는 지역의 매물을 직관적으로 확인할 수 있는 부동산 앱입니다.  
실시간 채팅과 예약금 결제를 통해 중개인과 원활하게 소통할 수 있으며,  
위치 기반 커뮤니티를 통해 동일 지역 사용자 간 교류를 지원합니다.


<br>

---
## 프로젝트 개요

- **최소 iOS 버전**: 16.0
- **디바이스 지원**: iPhone 전용

<br>


**기술 스택**

| Catetory                  | Technologies                                   |
| ------------------------- | ---------------------------------------------- |
| UI & Reactive             | SwiftUI, Combine                               |
| Architecture              | MVI, DIContainer                               |
| Database                  | Realm                                          |
| Network & Data            | REST API, WebSocket, URLSession, Keychain      |
| Caching & Performance     | NSCache                                        |
| System & Media Frameworks | PDFKit, AVFoundation, AVKit, ImageIO, PhotosUI |
| Map & Location            | KakaoMapSDK                                    |
| External                  | Kakao Login, Apple Sign In                     |

<br>

---
## 주요 기능 

| 기능    | 설명                       |
| ----- | ------------------------ |
| 로그인   | 이메일, 카카오, 애플 로그인 기능      |
| 결제    | PG결제를 통한 예약금 결제 기능       |
| 채팅    | 웹소켓을 통한 실시간 채팅 기능        |
| 매물 분포 지도 | 카카오맵 매물 표시 및 필터링 기능              |
| 알림    | 채팅 알림 기능 |
| 프로필   | 프로필 수정 및 조회 기능           |
| 커뮤니티   | 게시글 조회,수정,삭제, 댓글, 대댓글 기능          |
<br>

---
## 핵심 구현 내용

### 1. MVI 아키텍처 도입 - 단방향 데이터 플로우

이 프로젝트는 실시간 지도 기반 매물 검색, 복합 필터링, 결제 프로세스, WebSocket 채팅 등 다양한 기능을 포함하고 있습니다. 이러한 기능들로 인해 복잡한 비즈니스 로직과 상태 관리가 필요합니다. 따라서 뷰와 비즈니스 로직을 명확하게 분리하고, 뷰에서 발생하는 이벤트와 사용되는 데이터를 쉽게 파악하고 유연하게 수정, 확장할 수 있도록 MVI 아키텍처를 도입했습니다.

<br>

---
### 2. Factory + Internal 패턴을 통한 의존성 관리

이 프로젝트에서는 복잡한 데이터 요구사항을 가지고 있습니다:

- **다양한 데이터 소스**: 부동산 매물 정보, 사용자 인증, 결제 시스템, 채팅 데이터는 네트워크 API에서, 채팅 메시지 캐싱과 사용자 프로필은 로컬 데이터베이스에서, 지도와 결제는 외부 API에서 가져옵니다.
- **기능별 의존성 차이**: 채팅은 네트워크와 로컬 데이터베이스를 모두 사용하고, 매물 검색은 네트워크와 카카오맵 API를, 결제는 네트워크와 외부 결제 시스템을 연동해야 합니다.
- **테스트와 안정성**: 부동산 거래의 신뢰성을 위해 데이터 처리가 정확해야 하며, 복잡한 매물 타입과 필터링 로직에서 발생할 수 있는 버그를 줄이려면 테스트가 쉬운 구조가 필요합니다.

이러한 데이터의존성과 복잡한 비즈니스 로직을 효율적으로 관리하기 위해 **DIContainer**를 중심으로 **Factory+Internal패턴**을 결합한 **DI(의존성 주입)** 구조를 도입하였습니다.

**구현 방식**: <br>

1. **Factory + Internal 패턴**
- 의존성 생성을 Factory로 분리하고, `internal` 접근 제어를 통해 실제 구현체(`NetworkRepositoryImp`, `DatabaseRepositoryImp`)를 외부에서 직접 접근하지 못하도록 했습니다. 이를 통해 코드 간 연결을 최소화 하고 유지보수가 효율적으로 하였습니다.
 ```swift
internal enum NetworkRepositoryFactory {

static func create() -> NetworkRepository {

return NetworkRepositoryImp()

}

}

internal enum DatabaseRepositoryFactory {

static func create() throws -> DatabaseRepository {

return try DatabaseRepositoryImp()

}

}
```

2. **앱 시작 시 DIContainer 초기화** 
- 앱 시작 시 `DIContainer`를 한 번 생성해 모든 의존성을 초기화하고, 모든 Repository를 생성하고 관리합니다. 각 화면에 필요한 의존성만 주입하여 앱 전체에서 일관되게 데이터 소스를 관리할 수 있도록 하였습니다.
```swift
@MainActor

final class DIContainer: ObservableObject {

private let networkRepository: NetworkRepository

private let databaseRepository: DatabaseRepository

init() throws {

self.networkRepository = NetworkRepositoryFactory.create()

self.databaseRepository = try DatabaseRepositoryFactory.create()

}

}
```


3. **기능별 Container로 필요한 의존성 주입**
- 각 화면(로그인, 채팅, 매물 상세 등)은 독립적인 Container를 가지며, 필요한 Repository만 주입받아 사용합니다. 이를 통해 각 기능이 독립적으로 동작하며 불필요한 의존성이 생기지 않도록 하였습니다.
```swift
func makeLoginContainer() -> LoginContainer {

LoginContainer(repository: networkRepository)

}

func makeChattingContainer(roomId: String) -> ChattingContainer {

ChattingContainer(repository: networkRepository, databaseRepository: databaseRepository, roomId: roomId)

}

func makeEstateDetailContainer(estateId: String) -> EstateDetailContainer {

EstateDetailContainer(repository: networkRepository, estateId: estateId)

}
```


<br>

---

### 3. 계층 데이터 모델 구조 : DTO - Entity - Presentation

DTO-Entity-Presentation 3계층 구조를 채택하여 각 계층의 책임을 명확히 분리했습니다. 

- **DTO**
	- **역할**: 서버와 네트워크 통신에서 주고받는 원시 데이터를 처리합니다.
	- 모든 프로퍼티를 옵셔널로 선언해 서버에서 값이 누락되거나 형식 오류가 있을 경우 안전하게 수신하도록 하였습니다.

- **Entity**
	- **역할**: 앱 내부의 비즈니스 로직에서 사용하는 데이터 모델입니다.
	- `userId`와 같은 필수값은 DTO -> Entity 매핑 과정에서 `nil`을 반환하고 `CustomError.nilResponse`를 던져 필수 데이터 누락을 엄격히 관리합니다.
	- 따라서 비즈니스 계층에서는 유효한 데이터만 처리하도록 하였습니다.
```swift
extension DetailEstateResponseDTO {

func toEntity() -> DetailEstateEntity? {

guard let estateId = estateId, let creatorEntity = creator?.toEntity() else {

return nil // 필수 데이터 누락 시 nil 반환

}

return DetailEstateEntity(

estateId: estateId,

category: category ?? "알 수 없음", // 기본값 처리

title: title ?? "알 수 없음",

// ...

)

}

}
```

- **Presentaion**
	- **역할**: 뷰에 표시할 데이터를 처리합니다.
	- 모든 데이터를 `String` 타입으로 변환하여 뷰에서 타입 변환, 포맷팅, 옵셔널 처리를 하지 않도록 합니다.
	- `PresentationMapper`를 통해 금액, 면적, 층수, 날짜 등을 사용자 친화적인 형식으로 포맷팅합니다.
	- 이를 통해 뷰 레이어에서 복잡한 데이터 처리를 제거해 코드의 가독성을 높였습니다.

<br>

---

## 핵심 기능 설명


### 1. 회원 인증 시스템
#### 지원하는 로그인 방식

- **이메일 로그인**: 이메일과 비밀번호를 통한 인증
- **소셜 로그인**: Apple의 `Sign in with Apple`
- **카카오 로그인**: 카카오 SDK 활용

#### 회원가입 기능

- 이메일 중복 확인
- 실시간 유효성 검증
- 비밀번호 보안 강화
- 닉네임 검증
- 전화번호 입력
- 자기소개 작성

#### JWT 토큰 기반 인증

- **액세스 토큰**과 **리프레시 토큰** 관리
- 디바이스 토큰을 통한 푸시 알림 지원
- 자동 로그인 기능

#### TokenRefreshManager 특징

- `@MainActor`로 선언되어 모든 상태 변경이 **메인 스레드**에서 처리
- 토큰 갱신 중 발생하는 동시 요청들을 관리
- 토큰 만료 시 첫 번째 요청만 갱신을 시작하고, 나머지는 `pendingRequests` 큐에 저장
- **0.5초 쿨다운** 시간으로 빠른 연속 갱신 방지
- **최대 10개** 대기 요청으로 메모리 사용량 제어
- `Task.detached`를 사용하여 네트워크 요청을 백그라운드에서 실행
- RefreshToken 만료 시 자동 로그아웃 처리
- JWT 디코더를 통한 사전 토큰 갱신

<br>

---

### 2. 위치 기반 매물 검색 및 확인 기능

위치 기반 매물 검색 시스템은 사용자의 현재 위치나 검색한 주소를 중심으로 주변 매물을 지도상에 표시하고, 다양한 필터링과 클러스터링을 통한 매물 탐색을 지원합니다.

#### 주요 기능

- 주소 검색을 통한 특정 지역 매물 조회
- **카테고리**, **평수**, **월세**, **보증금 범위** 등 다양한 필터링
- 줌 레벨에 따른 동적 클러스터링
- 실시간 매물 데이터 업데이트
- 적응적 클러스터링 알고리즘

##### 클러스터링 동작 방식

- **여러 매물**: 하나의 클러스터로 그룹화
- **개별 매물**: 대표 이미지와 금액 표시
- **클러스터 탭**: 해당 지역의 매물 목록 확인
- **개별 매물 탭**: 상세 정보 조회

#### 1) 매물 클러스터링

##### 클러스터링 로직 (HDBSCAN + KDTREE)

- **HDBSCAN**: Hierarchical Density-Based Spatial Clustering of Applications with Noise
    - 밀도 기반 클러스터링으로 매물의 공간적 분포 고려
    - 노이즈 데이터 자동 분리
- **KDTree**: 성능 최적화를 위한 자료구조
    - 위도와 경도를 축으로 사용하여 공간 효율적 분할
    - k-최근접 이웃 검색을 통한 `O(n log n)` 복잡도로 core distance 계산

##### 클러스터링 과정

1. **Mutual reachability graph** 구성
2. **Kruskal 알고리즘**을 사용하여 최소 신장 트리 구축
3. 거리 임계값을 기준으로 클러스터 분할
4. 줌 레벨과 매물 분포에 따른 동적 임계값 조정

##### 핀 결정 로직 (루트보간법)

- 클러스터의 매물 수에 따라 **루트보간법** 적용
- 매물 수가 적은 클러스터: **작은 크기**
- 매물 수가 많은 클러스터: **큰 크기**
- 루트 함수를 사용하여 극단적인 크기 차이 방지
- **25pt ~ 50pt** 사이의 크기로 매핑

##### 랜덤 오프셋 (보안 기능)

개별 매물의 정확한 위치 보호를 위해 랜덤 오프셋을 적용합니다.

- **거리**: 30~80미터 범위에서 랜덤 생성
- **방향**: 0~360도 범위에서 랜덤 생성
- **적용 대상**: 개별 매물에만 적용 (클러스터 제외)

##### 2) 주소 검색 - GeoCoding 및 검색 결과 처리

##### 주소 + 키워드 통합 검색

검색 정확도를 높이기 위한 우선순위 설정:

1. **상세주소** (최우선)
2. **도로명주소**
3. **기본좌표**

##### 페이지네이션 적용

- 검색 결과: **30개 단위**로 순차 로딩
- 네트워크 부하 최소화

<br>

---

### 3. 위치 기반 커뮤니티 기능

위치 기반 커뮤니티 시스템은 사용자의 현재 위치를 중심으로 주변 게시물을 조회하고, 지역 기반 소통을 지원합니다.

#### 위치 설정

- 현재 위치에서 **최대 5km** 반경 내 게시물 조회(defalut)
- 거리 설정을 통한 검색 범위 조정

#### 게시물 카테고리

- 정보
- 친목
- 이슈
- 동물
- 분실
- 맛집

#### 정렬 옵션

- **최신순**
- **좋아요순**

#### 게시물 작성 기능

- 현재 위치 정보 자동 포함
- 다양한 파일 첨부: **이미지**, **비디오**, **PDF**
- 댓글과 대댓글 시스템
- 좋아요 기능

#### 검색 기능

- **위치 검색**: 특정 지역의 게시물 조회
- **제목 기반 검색**

#### 게시물 관리

- 수정 및 삭제 (작성자만 가능)
- 실시간 목록 업데이트

#### 댓글 시스템 최적화

- 임시 메시지를 즉시 UI에 표시
- 전송 실패 시 **재전송**과 **삭제** 옵션 제공
- 파일 업로드 시 중복 파일 검사
- 파일 크기와 형식 사전 검증

<br>

---

### 4. 결제 기능 (PG 기반 간편 결제)

#### 결제 프로세스

결제는 단방향 흐름으로 설계되어 명확한 오류 처리와 데이터 불일치 문제를 최소화합니다.

1. **결제 정보 검증**
2. **웹뷰를 통한 결제 페이지 호출**
3. **결제 완료 후 서버 검증**
4. **주문 확정**

#### 결제 단계별 오류 처리

##### 결제 정보 생성 오류

- **"다시 시도"** 버튼 제공
- 사용자가 즉시 재시도 가능

##### 서버 검증 실패

- 예: 결제 완료 후 금액 불일치
- **"고객센터 문의"** 버튼으로 사용자 손실 방지

##### 결제 취소 또는 실패

- 명확한 오류 메시지 표시

#### 이중 서버 검증

- 서버에서 `imp_uid`를 통해 결제 상태와 금액 재확인
- 결제 금액과 주문 금액의 불일치 감지
- 부정 결제 방지

#### 실시간 피드백

- 결제 상태에 따른 실시간 피드백 제공
- 결제 성공 시 자동으로 웹뷰 닫기
- 성공 메시지 표시

<br>

---

### 5. 웹뷰 브릿징 (이벤트)

#### 주요 기능

- 이벤트 페이지나 프로모션 콘텐츠를 웹뷰로 표시
- JavaScript와 네이티브 코드 간의 메시지 교환
- 출석 체크와 같은 이벤트 기능 구현

#### 출석 체크 프로세스

1. 사용자가 웹뷰 내에서 출석 버튼 클릭
2. 네이티브 앱의 인증 토큰을 JavaScript로 전송
3. 서버 인증 수행
4. 출석 완료 시 출석 횟수를 네이티브 앱으로 반환
5. UI 업데이트

#### 추가 기능

- `SafariWebView`를 통한 외부 웹페이지 안전 표시
- 딥링크를 통한 앱 간 전환
- URL 스킴 처리
- **출석 완료**, **오류 발생**, **웹뷰 닫기** 등의 이벤트 처리
- URL 로딩 시 앱의 **API 키**와 **액세스 토큰**을 헤더에 포함

<br>

---

### 6. 푸시 알림 (채팅 알림 수신 기능)

**Firebase Cloud Messaging** 기반의 실시간 채팅 알림 기능입니다.

#### 알림 동작 방식

##### 포그라운드 상태

- **커스텀 인앱 알림 배너** 표시
- 현재 채팅방에 있을 때는 해당 채팅방 알림 무시
- 2단계 구조: 벨 아이콘 → 상세 배너

##### 백그라운드 상태

- **시스템 알림** 표시
- 알림 탭 시 해당 채팅방으로 자동 이동

#### 알림 내용

- 발신자 이름
- 메시지 내용
- 채팅방 정보
- 읽지 않은 메시지 수

#### 시스템 구조

##### AppDelegate

- Firebase 초기화
- 디바이스 토큰 등록

##### SceneDelegate

- 실제 알림 수신과 처리
- `DeepLinkProcessor`를 통한 화면 전환
- `NotificationCenter`를 통한 앱 내부 동기화

#### 알림 그룹화

- 같은 채팅방에서 짧은 시간 내 여러 알림 발생 시
- **"새로운 메시지가 N개 있습니다"** 형태로 표시

#### 백그라운드 → 포그라운드 전환

- 대기 중인 딥링크 자동 처리
- 중복 채팅화면 쌓임 방지

#### 알림 카운트 관리

- 디바운싱 적용으로 안정적 처리
- 채팅방 진입 시 자동 카운트 초기화

<br>

---


### 7. 1:1 채팅 기능

1:1 채팅 시스템은 실시간 대화와 다양한 파일 공유를 지원합니다.

#### 파일 전송 제한

- **최대 파일 수**: 5개
- **파일 크기 제한**: 5MB 이하
- **지원 파일 형식**: 이미지, GIF, PDF

#### 메시지 전송 시스템

- 실시간 임시 메시지 표시 → 즉각적인 피드백
- 전송 완료 후 실제 메시지로 교체
- 전송 버튼 상태 관리 (텍스트 비어있거나 파일 제한 초과 시 비활성화)

#### 채팅 화면 구성

##### 메시지 표시

- 로드 시 항상 하단에 표시
- 새 메시지 수신 시 자동 하단 스크롤
- 날짜별 그룹화: **"2024년 01월 15일"** 형태의 구분선

##### 스크롤 관리

- 위로 스크롤 시 이전 메시지 로드
- **사용자가 하단에 있을 때**: 새 메시지 수신 시 자동 스크롤
- **사용자가 상단에 있을 때**: 새 메시지 버튼 표시

#### 파일 미리보기

- 선택된 파일을 **가로 스크롤**로 표시
- 각 파일의 개별 삭제 버튼
- 이미지와 PDF 구분하여 적절한 뷰어 제공
- 여러 이미지 시 **그리드 레이아웃** 표시

#### 데이터 저장 및 동기화

- **로컬 데이터베이스**와 **서버** 동기화
- 오프라인 상태에서도 이전 대화 확인 가능

#### 사용자 경험 향상

- 새 메시지 수신 시 버튼의 **흔들림 애니메이션**
- 스크롤 위치 추적을 통한 적응적 동작
- 파일 크기와 형식 실시간 검증
